                                                               < REDIS命令 >
##############key(键)###########################
1.del key1[,ke2,...]:删除一个或者多个key，不存在的key可忽略,返回值代表操作成功的记录数
2.dump key:序列化一个key
3.RESTORE key-again 	 "\x00\tweihuanbo\x06\x00\xf4Z\xd3$\xae$\x89\xbf"：为新key赋值为序列化时的值，并设置ttl(毫秒为单位)的时间,如果为0则不设置过期时间
4.exists key:验证key是否存在
5.EXPIRE key 30: 设置key过期时间为 30 秒，以秒为单位
6.PEXPIRE key milliseconds：和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间
7.EXPIREAT key 1355292000:设置UNIX时间戳格式的过期时间
8.PEXPIREAT key milliseconds-timestamp:和 EXPIREAT 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳
9.keys pattern:查找所有符合给定模式pattern的key
	KEYS * 匹配数据库中所有 key 
	KEYS h?llo 匹配 hello ， hallo 和 hxllo 等
	KEYS h*llo 匹配 hllo 和 heeeeello 等
	KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 
10.MIGRATE host port key destination-db timeout [COPY] [REPLACE]：
	将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除
	这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时
	当IOERR发生时，有以下两种情况：
		key可能存在两个实例中
		key可能只存在于当前实例
	即唯一不可能发生的情况是丢失key
	可选项：
		copy：不移除源实例上的key
		replace：替换目标实例上已存在的key
11.move key db：将当前数据库的 key 移动到给定的数据库 db 当中，当目标数据库存在相同的key则移动失败
12.OBJECT subcommand key：OBJECT 命令允许从内部察看给定 key 的 Redis 对象
	REFCOUNT 和 IDLETIME 返回数字
	ENCODING 返回相应的编码类型
13.PERSIST key：移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )
14.TTL key:以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)
15.PTTL key ：类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间
16.RANDOMKEY： 从当前数据库中随机返回(不删除)一个 key 
17.RENAME key newkey：将 key 改名为 newkey
	当 key 和 newkey 相同，或者 key 不存在时，返回一个错误
	当 newkey 已经存在时， RENAME 命令将覆盖旧值
18.RENAMENX key newkey:当且仅当 newkey 不存在时，将 key 改名为 newkey,当 key 不存在时，返回一个错误
19.RESTORE key ttl serialized-value:反序列化给定的序列化值，并将它和给定的 key 关联,参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间
	RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误
20.SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE destination]:
	最简单的 SORT 使用方法是 SORT key 和 SORT key DESC
	SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符
	排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数
	通过使用 BY 选项，可以让 key 按其他pattern键来排序(SORT uid BY user_level_*)
	使用 GET 选项， 可以根据排序的结果来取出相应的键值(SORT uid GET user_name_*)
	组合使用 BY 和 GET,先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值(SORT uid BY user_level_* GET user_name_*)
	获取多个外部键,按 uid 分别获取 user_level_{uid} 和 user_name_{uid}(SORT uid GET user_level_* GET user_name_*)
	GET 有一个额外的参数规则，那就是 —— 可以用 # 获取被排序键的值(SORT uid GET # GET user_level_* GET user_name_*)
	通过将一个不存在的键作为参数传给 BY 选项， 可以让 SORT 跳过排序操作， 直接返回结果(SORT uid BY not-exists-key),通过将这种用法和 GET 选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）(SORT uid BY not-exists-key GET # GET user_level_* GET user_name_*)
	可以不将用户的名字和级别保存在 user_name_{uid} 和 user_level_{uid} 两个字符串键中， 而是用一个带有 name 域和 level 域的哈希表 user_info_{uid} 来保存用户的名字和级别信息(HMSET user_info_1 name admin level 9999),之后， BY 和 GET 选项都可以用 key->field 的格式来获取哈希表中的域的值， 其中 key 表示哈希表键， 而 field 则表示哈希表的域(SORT uid BY user_info_*->level GET user_info_*->name)
	保存排序结果(SORT numbers STORE sorted-numbers),可以通过将 SORT 命令的执行结果保存，并用 EXPIRE 为结果设置生存时间，以此来产生一个 SORT 操作的结果缓存。这样就可以避免对 SORT 操作的频繁调用：只有当结果集过期时，才需要再调用一次 SORT 操作,另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行 SORT 操作，并保存为结果集)，具体参见 SETNX 命令
21.TYPE key:返回 key 所储存的值的类型(none (key不存在),string (字符串),list (列表),set (集合),zset (有序集),hash (哈希表))
22.SCAN 命令返回的每个元素都是一个数据库键(scan 0 match *a* count 10)
	SSCAN 命令返回的每个元素都是一个集合成员
	HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成
	ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成
	
##############string(字符串)###########################
1.APPEND key value：如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾，如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样
2.strlen key:获取key的长度，可以不存在返回0
3.SETRANGE key start value：可以用于覆盖或修改字符串，对于不存在的key当作空串处理
4.getrange key start end：可以获取指定index范围的字符串(包括 start 和 end 在内)返回所有(一个或多个)给定 key 的值，
5.DECR key：将 key 中储存的数字值减一，如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作（此时已经有了key），如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误
6.DECRBY key decrement：将 key 所储存的值减去减量 decrement，其他同上
7.GET key：返回 key 所关联的字符串值，如果 key 不存在那么返回特殊值 nil，假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值
8.GETSET key value：将给定 key 的值设为 value ，并返回 key 的旧值(old value)，当 key 存在但不是字符串类型时，返回一个错误，当 key 不存在返回nil并且把新值关联给key
	GETSET 可以和 INCR 组合使用，实现一个有原子性复位操作的计数器
9.INCR key：将 key 中储存的数字值增一，如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作（此时已经有了key），如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误
	可以通过组合使用 INCR 和 EXPIRE ，来达到只在规定的生存时间内进行计数的目的
10.INCRBY key increment：将 key 所储存的值加上增量 increment
11.INCRBYFLOAT key increment：为 key 中所储存的值加上浮点数增量 increment，如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作（此时已经有了key）
12.MGET key [key ...]：返回所有(一个或多个)给定 key 的值，如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败
13.MSET key value [key value ...]：同时设置一个或多个 key-value 对，如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作
14.MSETNX key value [key value ...]:同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在，否则都不会成功（返回值为0）
15.SETNX key value：设置一个key-value 对，当且仅当给定 key 不存在，否则不会成功（返回值为0）
16.SETEX key seconds value：将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)，如果 key 已经存在， SETEX 命令将覆写旧值
	（相当于SET key value
		EXPIRE key seconds  # 设置生存时间）
17.PSETEX key milliseconds value:设置 key,并以毫秒为单位设置 key 的生存时间
18.SETRANGE key offset value：用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始

##############stringHash（哈希表）###########################
1.HDEL key field [field ...]：删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略（返回值0）
2.HEXISTS key field：查看哈希表 key 中，给定域 field 是否存在
3.HSET key field value：将哈希表 key 中的域 field 的值设为 value，如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作，如果域 field 已经存在于哈希表中，旧值将被覆盖
4.HGET key field：返回哈希表 key 中给定域 field 的值，当给定域不存在或是给定 key 不存在时，返回 nil
5.HGETALL key：返回哈希表 key 中，所有的域和值，若 key 不存在，返回空列表（empty list or set）
6.HKEYS key：返回哈希表 key 中的所有域，当 key 不存在时，返回一个空表（empty list or set）
7.HVALS key：返回哈希表 key 中所有域的值，当 key 不存在时，返回一个空表（empty list or set）
8.HINCRBY key field increment：为哈希表 key 中的域 field 的值加上增量 increment，增量也可以为负数，相当于对给定域进行减法操作，如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令，如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 
9.HINCRBYFLOAT key field increment：为哈希表 key 中的域 field 加上浮点数增量 increment，其他同上
10.HLEN key：返回哈希表 key 中域的数量，当 key 不存在时，返回 0
11.HMSET key field value [field value ...]：同时将多个 field-value (域-值)对设置到哈希表 key 中，此命令会覆盖哈希表中已存在的域，如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作
12.HMGET key field [field ...]：返回哈希表 key 中，一个或多个给定域的值，如果给定的域不存在于哈希表，那么返回一个 nil 值，因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表
13.HSETNX key field value：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在，若域 field 已经存在，该操作无效，如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令
14.HSCAN key cursor [MATCH pattern] [COUNT count]：具体信息请参考 SCAN 命令
	--没有这个HMSETNX命令
	
##############List（列表）###########################
1.LPOP key：移除并返回列表 key 的头元素，当 key 不存在时，返回 nil
2.RPOP key：移除并返回列表 key 的尾元素，当 key 不存在时，返回 nil
3.BLPOP key [key ...] timeout：当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素，它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止，当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的[头]元素,timeout单位是秒
4.BRPOP key [key ...] timeout：它是 RPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止，当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的[尾]元素,timeout单位是秒
5.RPOPLPUSH source destination：将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端，将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素，如果 source 不存在，值 nil 被返回，并且不执行其他动作
6.BRPOPLPUSH source destination timeout:BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH 一样,当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH 或 RPUSH 命令为止,timeout单位是秒
7.LINDEX key index:返回列表 key 中，下标为 index 的元素,如果 key 不是列表类型，返回一个错误,index不在 mylist 的区间范围内返回nil
8.LINSERT key BEFORE|AFTER pivot value：将值 value 插入到列表 key 当中，位于值 pivot 之前或之后，当 pivot 不存在于列表 key 或者 key 不存在时，不执行任何操作，如果 key 不是列表类型，返回一个错误
9.LLEN key：返回列表 key 的长度，如果 key 不存在，则 key 被解释为一个空列表，返回 0，如果 key 不是列表类型，返回一个错误
10.L(R)PUSH key value [value ...]：将一个或多个值 value 插入到列表 key 的表头(尾)，如果 key 不存在，一个空列表会被创建并执行 L（R）PUSH 操作，当 key 存在但不是列表类型时，返回一个错误（列表允许重复元素）
11.L(R)PUSHX key value：将值 value 插入到列表 key 的表头（尾），当且仅当 key 存在并且是一个列表，和 L（R）PUSH 命令相反，当 key 不存在时， L（R）PUSHX 命令什么也不做
12.LRANGE key start stop：返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定，超出范围的下标值不会引起错误
13.LREM key count value:根据参数 count 的值，移除列表中与参数 value 相等的元素
	count > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count
	count < 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值
	count = 0 : 移除表中所有与 value 相等的值(删除全部value)
14.LSET key index value：将列表 key 下标为 index 的元素的值设置为 value，当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误
15.LTRIM key start stop：对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除，当 key 不是列表类型时，返回一个错误

##############Set（集合）###########################
1.SADD key member [member ...]：将一个或多个 member 元素加入到集合 key 当中，已经存在，假如 key 不存在，则创建一个只包含 member 元素作成员的集合，当 key 不是集合类型时，返回一个错误
2.SCARD key：返回集合 key 的基数(集合中元素的数量)，当 key 不存在时，返回 0
3.SDIFF key [key ...]：返回一个集合的全部成员，该集合是所有给定集合之间的差集，不存在的 key 被视为空集
4.SDIFFSTORE destination key [key ...]：这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集，如果 destination 集合已经存在，则将其覆盖（destination 可以是 key 本身）
5.SINTER key [key ...]：返回一个集合的全部成员，该集合是所有给定集合的交集，不存在的 key 被视为空集（sinter一个不存在的key结果是空集）
6.SINTERSTORE destination key [key ...]：这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集，如果 destination 集合已经存在，则将其覆盖，destination 可以是 key 本身
7.SISMEMBER key member：判断 member 元素是否集合 key 的成员，如果 member 元素不是集合的成员，或 key 不存在，返回 0
8.SMEMBERS key：返回集合 key 中的所有成员，不存在的 key 被视为空集合
9.SMOVE sourceSet destinationSet member：将 member 元素从 sourceSet 集合移动到 destinationSet 集合，如果 sourceSet 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 sourceSet 集合中被移除，并添加到 destinationSet 集合中去。当 destinationSet 集合已经包含 member 元素时， SMOVE 命令只是简单地将 sourceSet 集合中的 member 元素删除，当 sourceSet 或 destinationSet 不是集合类型时，返回一个错误
10.SPOP key [count]:移除并返回集合中的一个或count个[随机]元素,如果只想获取随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER [count]命令,当 key 不存在或 key 是空集时，返回 nil 
11.SRANDMEMBER key [count]:用法参考上述一条
12.SREM key member [member ...]：移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略，当key不存在返回0 ，当 key 不是集合类型，返回一个错误
13.SUNION key [key ...]：返回一个集合的全部成员，该集合是所有给定集合的并集，不存在的 key 被视为空集
14.SUNIONSTORE destination key [key ...]：这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集，如果 destination 已经存在，则将其覆盖，destination 可以是 key 本身
15.SSCAN key cursor [MATCH pattern] [COUNT count]：详细信息请参考 SCAN 命令

##############SortedSet（有序集合）###########################
1.ZADD key score member [[score member] [score member] ...]：将一个或多个 member 元素及其 score 值加入到有序集 key 当中，如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上，score 值可以是整数值或双精度浮点数，如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作，当 key 存在但不是有序集类型时，返回一个错误
2.ZCARD key：返回有序集 key 的基数，当 key 不存在时，返回 0
3.ZCOUNT key min max：返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量，
4.ZINCRBY key increment member：为有序集 key 的成员 member 的 score 值加上增量 increment ，可以通过传递一个负数值 increment ，让 score 减去相应的值，当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member ，当 key 不是有序集类型时，返回一个错误，score 值可以是整数值或双精度浮点数
5.ZRANGE key start stop [WITHSCORES]：返回有序集 key 中，指定index区间内的成员，其中成员的位置按 score 值递增(从小到大)来排序，如果需要成员按 score 值递减(从大到小)来排列，使用 ZREVRANGE 命令
6.ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列
7.ZRANK key member：返回有序集 key 中成员 member 的排名（index）。其中有序集成员按）。其中有序集成员按 score 值递增(从小到大)顺序排列
8.ZREM key member [member ...]：移除有序集 key 中的一个或多个成员，不存在的成员将被忽略，当 key 存在但不是有序集类型时，返回一个错误
9.ZREMRANGEBYRANK key start stop：移除有序集 key 中，指定排名(rank)区间内的所有成员
10.ZREMRANGEBYSCORE key min max：移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员
11.ZREVRANGE key start stop [WITHSCORES]：返回有序集 key 中，指定区间内的成员，其中成员的位置按 score 值递减(从大到小)来排列
12.ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]：返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列
13.ZREVRANK key member：返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序
14.ZSCORE key member：返回有序集 key 中，成员 member 的 score 值，如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil
15.ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]：计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination ，默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和，使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子，使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式
16.ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]：计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination ，默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和，关于 WEIGHTS 和 AGGREGATE 选项的描述同上
17.ZSCAN key cursor [MATCH pattern] [COUNT count]：详细信息请参考 SCAN 命令

##############Pub/Sub（发布/订阅）###########################
1.SUBSCRIBE channel [channel ...]：订阅给定的一个或多个频道的信息
2.UNSUBSCRIBE [channel [channel ...]]：指示客户端退订给定的频道
3.PSUBSCRIBE pattern [pattern ...]：订阅一个或多个符合给定模式的频道，每个模式以 * 作为匹配符，比如 it* 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)
4.PUNSUBSCRIBE [pattern [pattern ...]]：指示客户端退订所有给定模式
5.PUBLISH channel message：将信息 message 发送到指定的频道 channel，返回接收到信息 message 的订阅者数量
6.PUBSUB <subcommand> [argument [argument ...]]：略

##############Transaction（事务）###########################
1.DISCARD：取消事务，放弃执行事务块内的所有命令，如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH
2.EXEC：执行所有事务块内的命令
3.MULTI:标记一个事务块的开始
4.UNWATCH:取消 WATCH 命令对所有 key 的监视,如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了
5.WATCH key [key ...]:监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断

##############Script（脚本）------> 略 ###########################

##############Connection（连接）###########################
1.AUTH password：通过设置配置文件中 requirepass 项的值(使用命令 CONFIG SET requirepass password )，可以使用密码来保护 Redis 服务器，如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用 AUTH 命令解锁，解锁之后才能使用其他 Redis 命令
2.ECHO message：打印一个特定的信息 message ，测试时使用
3.PING：使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG，通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值
4.QUIT：请求服务器关闭与当前客户端的连接，一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭
5.SELECT index：切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值，默认使用 0 号数据库

##############Server（服务器）###########################
1.BGREWRITEAOF:执行一个 AOF文件 重写操作。重写会创建一个当前 AOF 文件的体积优化版本,即使 BGREWRITEAOF 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 BGREWRITEAOF 成功之前不会被修改,从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作
2.bgsave:在后台异步(Asynchronously)保存当前数据库的数据到磁盘,客户端可以通过 LASTSAVE 命令查看相关信息，判断 BGSAVE 命令是否执行成功
3.CLIENT SETNAME connection-name:为当前连接分配一个名字,这个名字会显示在 CLIENT LIST 命令的结果中， 用于识别当前正在与服务器进行连接的客户端
4.CLIENT GETNAME:返回 CLIENT SETNAME 命令为连接设置的名字,因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回(nil)
5.CLIENT KILL ip:port:关闭地址为 ip:port 的客户端
6.CLIENT LIST:以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据
	以下是域的含义：

	addr ： 客户端的地址和端口
	fd ： 套接字所使用的文件描述符
	age ： 以秒计算的已连接时长
	idle ： 以秒计算的空闲时长
	flags ： 客户端 flag （见下文）
	db ： 该客户端正在使用的数据库 ID
	sub ： 已订阅频道的数量
	psub ： 已订阅模式的数量
	multi ： 在事务中被执行的命令数量
	qbuf ： 查询缓存的长度（ 0 表示没有查询在等待）
	qbuf-free ： 查询缓存的剩余空间（ 0 表示没有剩余空间）
	obl ： 输出缓存的长度
	oll ： 输出列表的长度（当输出缓存没有剩余空间时，回复被入队到这个队列里）
	omem ： 输出缓存的内存占用量
	events ： 文件描述符事件（见下文）
	cmd ： 最近一次执行的命令
	客户端 flag 可以由以下部分组成：

	O ： 客户端是 MONITOR 模式下的附属节点（slave）
	S ： 客户端是一般模式下（normal）的附属节点
	M ： 客户端是主节点（master）
	x ： 客户端正在执行事务
	b ： 客户端正在等待阻塞事件
	i ： 客户端正在等待 VM I/O 操作（已废弃）
	d ： 一个受监视（watched）的键已被修改， EXEC 命令将失败
	c : 在将回复完整地写出之后，关闭链接
	u : 客户端未被阻塞（unblocked）
	A : 尽可能快地关闭连接
	N : 未设置任何 flag
	文件描述符事件可以是：

	r : 客户端套接字（在事件 loop 中）是可读的（readable）
	w : 客户端套接字（在事件 loop 中）是可写的（writeable）
7.CONFIG SET parameter value：CONFIG SET 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启，CONFIG SET 可以修改的配置参数可以使用命令 CONFIG GET * 来列出，所有被 CONFIG SET 修改的配置参数都会立即生效
8.CONFIG GET parameter:用于取得运行中的 Redis 服务器的配置参数(configuration parameters),接受单个参数 parameter 作为搜索关键字，查找所有匹配的配置参数，其中参数和值以“键-值对”(key-value pairs)的方式排列（如执行 CONFIG GET s* 命令，服务器就会返回所有以 s 开头的配置参数及参数的值）
9.CONFIG RESETSTAT：重置 INFO 命令中的某些统计数据，包括：

	Keyspace hits (键空间命中次数)
	Keyspace misses (键空间不命中次数)
	Number of commands processed (执行命令的次数)
	Number of connections received (连接服务器的次数)
	Number of expired keys (过期key的数量)
	Number of rejected connections (被拒绝的连接数量)
	Latest fork(2) time(最后执行 fork(2) 的时间)
	The aof_delayed_fsync counter(aof_delayed_fsync 计数器的值)
10.CONFIG REWRITE：CONFIG REWRITE 命令对启动 Redis 服务器时所指定的 redis.conf 文件进行改写： 因为 CONFIG SET 命令可以对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中
	重写会以非常保守的方式进行：

	原有 redis.conf 文件的整体结构和注释会被尽可能地保留。
	如果一个选项已经存在于原有 redis.conf 文件中 ， 那么对该选项的重写会在选项原本所在的位置（行号）上进行。
	如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为默认值， 那么重写程序不会将这个选项添加到重写后的 redis.conf 文件中。
	如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为非默认值， 那么这个选项将被添加到重写后的 redis.conf 文件的末尾。
	未使用的行会被留白。 比如说， 如果你在原有 redis.conf 文件上设置了数个关于 save 选项的参数， 但现在你将这些 save 参数的一个或全部都关闭了， 那么这些不再使用的参数原本所在的行就会变成空白的。
	即使启动服务器时所指定的 redis.conf 文件已经不再存在， CONFIG REWRITE 命令也可以重新构建并生成出一个新的 redis.conf 文件。

	另一方面， 如果启动服务器时没有载入 redis.conf 文件， 那么执行 CONFIG REWRITE 命令将引发一个错误
11.DBSIZE：返回当前数据库的 key 的数量
12.DEBUG OBJECT key：DEBUG OBJECT 是一个调试命令，它不应被客户端所使用（既然客户端不可用 这个命令真正的用处是啥）
13.DEBUG SEGFAULT：执行一个不合法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 模拟（执行了redis客户端就down了 不明觉厉）
14.FLUSHALL：清空整个 Redis 服务器的数据(删除所有数据库的所有 key )
15.FLUSHDB：清空当前数据库中的所有 key
16.INFO [section]：以一种易于解释（parse）且易于阅读的格式，返回关于 Redis 服务器的各种信息和统计数值
	通过给定可选的参数 section ，可以让命令只返回某一部分的信息
	server : 一般 Redis 服务器信息，包含以下域：

	redis_version : Redis 服务器版本
	redis_git_sha1 : Git SHA1
	redis_git_dirty : Git dirty flag
	os : Redis 服务器的宿主操作系统
	arch_bits : 架构（32 或 64 位）
	multiplexing_api : Redis 所使用的事件处理机制
	gcc_version : 编译 Redis 时所使用的 GCC 版本
	process_id : 服务器进程的 PID
	run_id : Redis 服务器的随机标识符（用于 Sentinel 和集群）
	tcp_port : TCP/IP 监听端口
	uptime_in_seconds : 自 Redis 服务器启动以来，经过的秒数
	uptime_in_days : 自 Redis 服务器启动以来，经过的天数
	lru_clock : 以分钟为单位进行自增的时钟，用于 LRU 管理
	clients : 已连接客户端信息，包含以下域：

	connected_clients : 已连接客户端的数量（不包括通过从属服务器连接的客户端）
	client_longest_output_list : 当前连接的客户端当中，最长的输出列表
	client_longest_input_buf : 当前连接的客户端当中，最大输入缓存
	blocked_clients : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量
	memory : 内存信息，包含以下域：

	used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位
	used_memory_human : 以人类可读的格式返回 Redis 分配的内存总量
	used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。
	used_memory_peak : Redis 的内存消耗峰值（以字节为单位）
	used_memory_peak_human : 以人类可读的格式返回 Redis 的内存消耗峰值
	used_memory_lua : Lua 引擎所使用的内存大小（以字节为单位）
	mem_fragmentation_ratio : used_memory_rss 和 used_memory 之间的比率
	mem_allocator : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。
	在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。
	当 rss > used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。
	内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。
	当 used > rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。
	Because Redis does not have control over how its allocations are mapped to memory pages, high used_memory_rss is often the result of a spike in memory usage.

	当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。
	如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。
	查看 used_memory_peak 的值可以验证这种情况是否发生。
	persistence : RDB 和 AOF 的相关信息

	stats : 一般统计信息

	replication : 主/从复制信息

	cpu : CPU 计算量统计信息

	commandstats : Redis 命令统计信息

	cluster : Redis 集群信息

	keyspace : 数据库相关的统计信息

	除上面给出的这些值以外，参数还可以是下面这两个：

	all : 返回所有信息
	default : 返回默认选择的信息
	当不带参数直接调用 INFO 命令时，使用 default 作为默认参数
17.LASTSAVE:返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示
18.MONITOR:实时打印出 Redis 服务器接收到的命令，调试用(不明觉厉)
19.PSYNC <MASTER_RUN_ID> <OFFSET>：用于复制功能(replication)的内部命令（不明觉厉）
20.SAVE：SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘，一般来说，在生产环境很少执行 SAVE 操作，因为它会阻塞所有客户端，保存数据库的任务通常由 BGSAVE 命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， SAVE 可以作为保存数据的最后手段来使用
21.SHUTDOWN：如果持久化被打开的话， SHUTDOWN 命令会保证服务器正常关闭而不丢失任何数据,另一方面，假如只是单纯地执行 SAVE 命令，然后再执行 QUIT 命令，则没有这一保证
	SHUTDOWN 命令执行以下操作：

	停止所有客户端
	如果有至少一个保存点在等待，执行 SAVE 命令
	如果 AOF 选项被打开，更新 AOF 文件
	关闭 redis 服务器(server)
	
	执行 SHUTDOWN SAVE 会强制让数据库执行保存操作，即使没有设定(configure)保存点  --不清楚
	执行 SHUTDOWN NOSAVE 会阻止数据库执行保存操作，即使已经设定有一个或多个保存点  --不清楚
22.SLAVEOF host port:SLAVEOF 命令用于在 Redis 运行时动态地修改复制(replication)功能的行为,通过执行 SLAVEOF host port 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)
23.SLOWLOG subcommand [argument]:
	第一个选项是 slowlog-log-slower-than ，它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录
	另一个选项是 slowlog-max-len ，它决定 slow log 最多能保存多少条日志， slow log 本身是一个 FIFO 队列，当队列大小超过 slowlog-max-len 时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log
	要查看 slow log ，可以使用 SLOWLOG GET 或者 SLOWLOG GET number 命令，前者打印所有 slow log ，最大长度取决于 slowlog-max-len 选项的值，而 SLOWLOG GET number 则只打印指定数量的日志
	最新的日志会最先被打印
	使用命令 SLOWLOG LEN 可以查看当前日志的数量
24.SYNC	:用于复制功能(replication)的内部命令(不明觉厉)
25.TIME：返回当前服务器时间，返回值包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数

																	< REDIS文档（部分） >
1.使用 WATCH 实现 ZPOP：

	WATCH zset
	element = ZRANGE zset 0 0
	MULTI
		ZREM zset element
	EXEC
	程序只要重复执行这段代码， 直到 EXEC 的返回值不是空多条回复（null multi-bulk reply）即可
	
2.SUBSCRIBE 、 UNSUBSCRIBE 和 PUBLISH 三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者
3.	
































	
	
	

